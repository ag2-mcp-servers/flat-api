# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T19:15:29+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query
from pydantic import conint

from models import (
    Assignment,
    AssignmentCopy,
    AssignmentCreation,
    AssignmentSubmission,
    AssignmentSubmissionComment,
    AssignmentSubmissionCommentCreation,
    AssignmentSubmissionUpdate,
    ClassCreation,
    ClassDetails,
    ClassesClassAssignmentsAssignmentSubmissionsGetResponse,
    ClassesClassAssignmentsAssignmentSubmissionsSubmissionCommentsGetResponse,
    ClassesClassAssignmentsAssignmentSubmissionsSubmissionHistoryGetResponse,
    ClassesClassAssignmentsGetResponse,
    ClassesClassStudentsUserSubmissionsGetResponse,
    ClassesGetResponse,
    ClassUpdate,
    Collection,
    CollectionCreation,
    CollectionModification,
    CollectionsCollectionScoresGetResponse,
    CollectionsGetResponse,
    Direction,
    FlatErrorResponse,
    Format,
    Group1,
    GroupDetails,
    GroupsGroupScoresGetResponse,
    GroupsGroupUsersGetResponse,
    LicenseExpirationDate,
    LtiCredentials,
    LtiCredentialsCreation,
    OrganizationInvitation,
    OrganizationInvitationCreation,
    OrganizationsInvitationsGetResponse,
    OrganizationsLtiCredentialsGetResponse,
    OrganizationsUsersCountGetResponse,
    OrganizationsUsersGetResponse,
    ResourceCollaborator,
    ResourceCollaboratorCreation,
    Role,
    Role2,
    Role3,
    ScoreComment,
    ScoreCommentCreation,
    ScoreCommentUpdate,
    ScoreCreation,
    ScoreDetails,
    ScoreFork,
    ScoreModification,
    ScoreRevision,
    ScoreRevisionCreation,
    ScoresScoreCollaboratorsGetResponse,
    ScoresScoreCommentsGetResponse,
    ScoresScoreRevisionsGetResponse,
    ScoresScoreSubmissionsGetResponse,
    ScoresScoreTracksGetResponse,
    ScoreTrack,
    ScoreTrackCreation,
    ScoreTrackUpdate,
    Sort,
    Sort2,
    Sort4,
    Sort5,
    Source,
    State2,
    Type7,
    UserAdminUpdate,
    UserCreation,
    UserDetails,
    UserDetailsAdmin,
    UserPublic,
    UsersUserLikesGetResponse,
    UsersUserScoresGetResponse,
)

app = MCPProxy(
    contact={
        'email': 'developers@flat.io',
        'name': 'Flat',
        'url': 'https://flat.io/developers/docs/api/',
    },
    description="The Flat API allows you to easily extend the abilities of the [Flat Platform](https://flat.io), with a wide range of use cases including the following:\n\n* Creating and importing new music scores using MusicXML, MIDI, Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar and MuseScore files\n* Browsing, updating, copying, exporting the user's scores (for example in MP3, WAV or MIDI)\n* Managing educational resources with Flat for Education: creating & updating the organization accounts, the classes, rosters and assignments.\n\nThe Flat API is built on HTTP. Our API is RESTful It has predictable resource URLs. It returns HTTP response codes to indicate errors. It also accepts and returns JSON in the HTTP body.\nThe [schema](/swagger.yaml) of this API follows the [OpenAPI Initiative (OAI) specification](https://www.openapis.org/), you can use and work with [compatible Swagger tools](http://swagger.io/open-source-integrations/).\nThis API features Cross-Origin Resource Sharing (CORS) implemented in compliance with [W3C spec](https://www.w3.org/TR/cors/).\n\nYou can use your favorite HTTP/REST library for your programming language to use Flat's API. This specification and reference is [available on Github](https://github.com/FlatIO/api-reference).\n\nGetting Started and learn more:\n\n* [API Overview and introduction](https://flat.io/developers/docs/api/)\n* [Authentication (Personal Access Tokens or OAuth2)](https://flat.io/developers/docs/api/authentication.html)\n* [SDKs](https://flat.io/developers/docs/api/sdks.html)\n* [Rate Limits](https://flat.io/developers/docs/api/rate-limits.html)\n* [Changelog](https://flat.io/developers/docs/api/changelog.html)\n",
    termsOfService='https://flat.io/legal',
    title='Flat API',
    version='2.13.0',
    servers=[{'url': 'https://api.flat.io/v2'}],
)


@app.get(
    '/classes',
    tags=['class_management', 'class_user_enrollment', 'user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_classes(state: Optional[State2] = 'active'):
    """
    List the classes available for the current user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes',
    description=""" Classrooms on Flat allow you to create activities with assignments and post content to a specific group.

When creating a class, Flat automatically creates two groups: one for the teachers of the course, one for the students. The creator of this class is automatically added to the teachers group.

If the classsroom is synchronized with another application like Google Classroom, some of the meta information will automatically be updated.

You can add users to this class using `PUT /classes/{class}/users/{user}`, they will automatically added to the group based on their role on Flat. Users can also enroll themselves to this class using `POST /classes/enroll/{enrollmentCode}` and the `enrollmentCode` returned in the `ClassDetails` response.
 """,
    tags=['class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_class(body: ClassCreation):
    """
    Create a new class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/enroll/{enrollmentCode}',
    description=""" Use this method to join a class using an enrollment code given one of the teacher of this class. This code is also available in the `ClassDetails` returned to the teachers when creating the class or listing / fetching a specific class.

Flat will automatically add the user to the corresponding class group based on this role in the organization.
 """,
    tags=['class_management', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def enroll_class(enrollment_code: str = Path(..., alias='enrollmentCode')):
    """
    Join a class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}',
    tags=['class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_class(class_: str = Path(..., alias='class')):
    """
    Get the details of a single class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/classes/{class}',
    description=""" Update the meta information of the class
 """,
    tags=['class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_class(class_: str = Path(..., alias='class'), body: ClassUpdate = None):
    """
    Update the class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/{class}/activate',
    description=""" Mark the class as `active`. This is mainly used for classes synchronized from Clever that are initially with an `inactive` state and hidden in the UI.
 """,
    tags=['class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def activate_class(class_: str = Path(..., alias='class')):
    """
    Activate the class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/classes/{class}/archive',
    description=""" Mark the class as `active`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated.
 """,
    tags=['class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def unarchive_class(class_: str = Path(..., alias='class')):
    """
    Unarchive the class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/{class}/archive',
    description=""" Mark the class as `archived`. When this course is synchronized with another app, like Google Classroom, this state will be automatically be updated.
 """,
    tags=['class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def archive_class(class_: str = Path(..., alias='class')):
    """
    Archive the class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments',
    tags=['assignment_control', 'class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_assignments(class_: str = Path(..., alias='class')):
    """
    Assignments listing
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/{class}/assignments',
    description=""" Use this method as a teacher to create and post a new assignment to a class.

If the class is synchronized with Google Classroom, the assignment will be automatically posted to your Classroom course.
 """,
    tags=['assignment_control', 'class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_assignment(
    class_: str = Path(..., alias='class'), body: AssignmentCreation = None
):
    """
    Assignment creation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/classes/{class}/assignments/{assignment}/archive',
    description=""" Mark the assignment as `active`.
 """,
    tags=['assignment_control', 'class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def unarchive_assignment(class_: str = Path(..., alias='class'), assignment: str = ...):
    """
    Unarchive the assignment.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/{class}/assignments/{assignment}/archive',
    description=""" Archive the assignment
 """,
    tags=['assignment_control', 'class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def archive_assignment(class_: str = Path(..., alias='class'), assignment: str = ...):
    """
    Archive the assignment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/{class}/assignments/{assignment}/copy',
    description=""" Copy an assignment to a specified class.

If the original assignment has a due date in the past, this new assingment will be created without a due date.

If the new class is synchronized with an external app (e.g. Google Classroom), the copied assignment will also be posted on the external app.
 """,
    tags=['assignment_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def copy_assignment(
    class_: str = Path(..., alias='class'),
    assignment: str = ...,
    body: AssignmentCopy = ...,
):
    """
    Copy an assignment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments/{assignment}/submissions',
    tags=['submission_control', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_submissions(class_: str = Path(..., alias='class'), assignment: str = ...):
    """
    List the students' submissions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/classes/{class}/assignments/{assignment}/submissions',
    description=""" Use this method as a student to create, update and submit a submission related to an assignment.
Students can only set `attachments` and `submit`.
Teachers can use `PUT /classes/{class}/assignments/{assignment}/submissions/{submission}` to update a submission by id.
 """,
    tags=['submission_control', 'assignment_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_submission(
    class_: str = Path(..., alias='class'),
    assignment: str = ...,
    body: AssignmentSubmissionUpdate = ...,
):
    """
    Create or edit a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments/{assignment}/submissions/csv',
    description=""" Export list of submissions grades to a CSV file """,
    tags=['collection_operations', 'assignment_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def export_submissions_reviews_as_csv(
    class_: str = Path(..., alias='class'), assignment: str = ...
):
    """
    CSV Grades exports
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments/{assignment}/submissions/excel',
    description=""" Export list of submissions grades to an Excel file """,
    tags=['assignment_control', 'collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def export_submissions_reviews_as_excel(
    class_: str = Path(..., alias='class'), assignment: str = ...
):
    """
    Excel Grades exports
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}',
    description=""" Use this method as a teacher to delete a submission and allow student to start over the assignment
 """,
    tags=['submission_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_submission(
    class_: Union[str, str, str, str] = Path(..., alias='class'),
    assignment: Union[str, str, str, str] = ...,
    submission: Union[str, str, str, str] = ...,
):
    """
    Delete a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}',
    tags=['submission_control', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_submission(
    class_: str = Path(..., alias='class'), assignment: str = ..., submission: str = ...
):
    """
    Get a student submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}',
    description=""" Use this method as a teacher to update the different submission and give feedback.
Teachers can only set `return`, `draftGrade` and `grade`
 """,
    tags=['submission_control', 'assignment_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_submission(
    class_: str = Path(..., alias='class'),
    assignment: str = ...,
    submission: str = ...,
    body: AssignmentSubmissionUpdate = ...,
):
    """
    Edit a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}/comments',
    tags=['submission_control', 'comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_submission_comments(
    class_: str = Path(..., alias='class'), assignment: str = ..., submission: str = ...
):
    """
    List the feedback comments of a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}/comments',
    tags=['submission_control', 'comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_submission_comment(
    class_: str = Path(..., alias='class'),
    assignment: str = ...,
    submission: str = ...,
    body: AssignmentSubmissionCommentCreation = ...,
):
    """
    Add a feedback comment to a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}/comments/{comment}',
    tags=['submission_control', 'comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_submission_comment(
    class_: str = Path(..., alias='class'),
    assignment: str = ...,
    submission: str = ...,
    comment: str = ...,
):
    """
    Delete a feedback comment to a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}/comments/{comment}',
    tags=['submission_control', 'comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_submission_comment(
    class_: str = Path(..., alias='class'),
    assignment: str = ...,
    submission: str = ...,
    comment: str = ...,
    body: AssignmentSubmissionCommentCreation = ...,
):
    """
    Update a feedback comment to a submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/assignments/{assignment}/submissions/{submission}/history',
    description=""" For teachers only. Returns a detailed history of the submission. This currently includes state and grade histories.
 """,
    tags=['submission_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_submission_history(
    class_: str = Path(..., alias='class'), assignment: str = ..., submission: str = ...
):
    """
    Get the history of the submission
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/classes/{class}/students/{user}/submissions',
    description=""" Use this method as a teacher to list all the assignment submissions sent by a student of the class
 """,
    tags=['submission_control', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_class_student_submissions(
    class_: str = Path(..., alias='class'), user: str = ...
):
    """
    List the submissions for a student
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/classes/{class}/users/{user}',
    description=""" This method can be used by a teacher to remove a user from the class, or by a student to leave the classroom.

Warning: Removing a user from the class will remove the associated resources, including the submissions and feedback related to these submissions.
 """,
    tags=['class_user_enrollment', 'class_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_class_user(class_: str = Path(..., alias='class'), user: str = ...):
    """
    Remove a user from the class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/classes/{class}/users/{user}',
    description=""" This method can be used by a teacher of the class to enroll another Flat user into the class.

Only users that are part of your Organization can be enrolled in a class of this same Organization.

When enrolling a user in the class, Flat will automatically add this user to the corresponding Class group, based on this role in the Organization.
 """,
    tags=['class_management', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_class_user(class_: str = Path(..., alias='class'), user: str = ...):
    """
    Add a user to the class
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/collections',
    description=""" Use this method to list the user's collections contained in `parent` (by default in the `root` collection).
If no sort option is provided, the collections are sorted by `creationDate` `desc`.

Note that this method will not include the `parent` collection in the listing.
For example, if you need the details of the `root` collection, you can use `GET /v2/collections/root`.
 """,
    tags=['collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_collections(
    parent: Optional[str] = 'root',
    sort: Optional[Sort] = None,
    direction: Optional[Direction] = None,
    limit: Optional[conint(ge=1, le=100)] = 25,
    next: Optional[str] = None,
    previous: Optional[str] = None,
):
    """
    List the collections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/collections',
    description=""" This method will create a new collection and add it to your `root` collection.
 """,
    tags=['collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_collection(body: CollectionCreation):
    """
    Create a new collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/collections/{collection}',
    description=""" This method will schedule the deletion of the collection. Until deleted, the collection will be available in the `trash`.
 """,
    tags=['collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_collection(collection: str):
    """
    Delete the collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/collections/{collection}',
    tags=['collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_collection(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'), collection: str = ...
):
    """
    Get collection details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/collections/{collection}',
    tags=['collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_collection(collection: str, body: CollectionModification = None):
    """
    Update a collection's metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/collections/{collection}/scores',
    description=""" Use this method to list the scores contained in a collection.
If no sort option is provided, the scores are sorted by `modificationDate` `desc`.
 """,
    tags=['collection_operations', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_collection_scores(
    sort: Optional[Sort2] = None,
    direction: Optional[Direction] = None,
    limit: Optional[conint(ge=1, le=100)] = 25,
    next: Optional[str] = None,
    previous: Optional[str] = None,
    collection: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    List the scores contained in a collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/collections/{collection}/scores/{score}',
    description=""" This method will delete a score from the collection. Unlike [`DELETE /scores/{score}`](#operation/deleteScore), this score will not remove the score from your account, but only from the collection.
This can be used to *move* a score from one collection to another, or simply remove a score from one collection when this one is contained in multiple collections.
 """,
    tags=['collection_operations', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_score_from_collection(
    collection: str,
    score: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    Delete a score from the collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/collections/{collection}/scores/{score}',
    description=""" This operation will add a score to a collection. The default behavior will make the score available across multiple collections.
You must have the capability `canAddScores` on the provided `collection` to perform the action.
 """,
    tags=['collection_operations', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_score_to_collection(
    collection: str,
    score: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    Add a score to the collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/collections/{collection}/untrash',
    description=""" This method will restore the collection by removing it from the `trash` and add it back to the `root` collection.
 """,
    tags=['collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def untrash_collection(collection: str):
    """
    Untrash a collection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/groups/{group}',
    tags=['group_overview'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_group_details(group: str):
    """
    Get group information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/groups/{group}/scores',
    description=""" Get the list of scores shared with a group.
 """,
    tags=['group_overview', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_group_scores(parent: Optional[str] = None, group: str = ...):
    """
    List group's scores
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/groups/{group}/users',
    tags=['group_overview', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_group_users(source: Optional[Source] = None, group: str = ...):
    """
    List group's users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me',
    description=""" Get details about the current authenticated User.
 """,
    tags=['user_profile_access'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_authenticated_user(only_id: Optional[bool] = Query(False, alias='onlyId')):
    """
    Get current user profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/invitations',
    tags=['user_account_management', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_organization_invitations(
    role: Optional[Role] = None,
    limit: Optional[conint(ge=1, le=1000)] = 50,
    next: Optional[str] = None,
    previous: Optional[str] = None,
):
    """
    List the organization invitations
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/invitations',
    description=""" This method creates and sends invitation for teachers and admins.

Invitations can only be used by new Flat users or users who are not part of the organization yet.

If the email of the user is already associated to a user of your organization, the API will simply update the role of the existing user and won't send an invitation. In this case, the property `usedBy` will be directly filled with the uniquer identifier of the corresponding user.
 """,
    tags=['user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_organization_invitation(body: OrganizationInvitationCreation = None):
    """
    Create a new invitation to join the organization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/invitations/{invitation}',
    tags=['user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_organization_invitation(invitation: str):
    """
    Remove an organization invitation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/lti/credentials',
    tags=['lti_credentials_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_lti_credentials():
    """
    List LTI 1.x credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/lti/credentials',
    description=""" Flat for Education is a Certified LTI Provider. You can use these API methods to automate the creation of LTI credentials. You can read more about our LTI implementation, supported components and LTI Endpoints in our [Developer Documentation](https://flat.io/developers/docs/lti/).
 """,
    tags=['lti_credentials_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_lti_credentials(body: LtiCredentialsCreation):
    """
    Create a new couple of LTI 1.x credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/lti/credentials/{credentials}',
    tags=['lti_credentials_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def revoke_lti_credentials(credentials: str):
    """
    Revoke LTI 1.x credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/users',
    tags=['user_account_management', 'class_user_enrollment', 'group_overview'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_organization_users(
    sort: Optional[Sort4] = None,
    direction: Optional[Direction] = None,
    next: Optional[str] = None,
    previous: Optional[str] = None,
    role: Optional[Role2] = None,
    q: Optional[str] = None,
    group: Optional[Group1] = None,
    no_active_license: Optional[bool] = Query(None, alias='noActiveLicense'),
    license_expiration_date: Optional[LicenseExpirationDate] = Query(
        None, alias='licenseExpirationDate'
    ),
    only_ids: Optional[bool] = Query(None, alias='onlyIds'),
    limit: Optional[conint(ge=1, le=1000)] = 25,
):
    """
    List the organization users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/organizations/users',
    tags=['user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_organization_user(body: UserCreation = None):
    """
    Create a new user account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/organizations/users/count',
    tags=['user_account_management', 'group_overview'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def count_orga_users(
    role: Optional[Role3] = None,
    q: Optional[str] = None,
    group: Optional[Group1] = None,
    no_active_license: Optional[bool] = Query(None, alias='noActiveLicense'),
):
    """
    Count the organization users using the provided filters
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/organizations/users/{user}',
    description=""" This operation removes an account from Flat and its data, including:
* The music scores created by this user (documents, history, comments, collaboration information)
* Education related data (assignments and classroom information)
 """,
    tags=['user_account_management', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_organization_user(
    convert_to_individual: Optional[bool] = Query(None, alias='convertToIndividual'),
    user: str = ...,
):
    """
    Remove an account from Flat
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/organizations/users/{user}',
    tags=['user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_organization_user(user: str, body: UserAdminUpdate = ...):
    """
    Update account information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores',
    description=""" Use this API method to **create a new music score in the current User account**. You will need a MusicXML 3 (`vnd.recordare.musicxml` or `vnd.recordare.musicxml+xml`), a MIDI (`audio/midi`), Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar, or MuseScore file to create the new Flat document.

This API call will automatically create the first revision of the document, the score can be modified by the using our web application or by uploading a new revision of this file (`POST /v2/scores/{score}/revisions/{revision}`).

The currently authenticated user will be granted owner of the file and will be able to add other collaborators (users and groups).

If no `collection` is specified, the API will create the score in the most appropriate collection. This can be the `root` collection or a different collection based on the user's settings or API authentication method.
If a `collection` is specified and this one has more public privacy settings than the score (e.g. `public` vs `private` for the score), the privacy settings of the created score will be adjusted to the collection ones.
You can check the adjusted privacy settings in the returned score `privacy`, and optionally adjust these settings if needed using `PUT /scores/{score}`.
 """,
    tags=['score_tracking', 'collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_score(body: ScoreCreation):
    """
    Create a new score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/scores/{score}',
    description=""" This method can be used by the owner/admin (`aclAdmin` rights) of a score as well as regular collaborators.

When called by an owner/admin, it will schedule the deletion of the score, its revisions, and complete history.
The score won't be accessible anymore after calling this method and the user's quota will directly be updated.

When called by a regular collaborator (`aclRead` / `aclWrite`), the score will be unshared (i.e. removed from the account & own collections).
 """,
    tags=['collection_operations', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_score(now: Optional[bool] = False, score: str = ...):
    """
    Delete a score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}',
    description=""" Get the details of a score identified by the `score` parameter in the URL.
The currently authenticated user must have at least a read access to the document to use this API call.
 """,
    tags=['score_tracking', 'collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'), score: str = ...
):
    """
    Get a score's metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/scores/{score}',
    description=""" This API method allows you to change the metadata of a score document (e.g. its `title` or `privacy`), all the properties are optional.

To edit the file itself, create a new revision using the appropriate method (`POST /v2/scores/{score}/revisions/{revision}`).

When editing the `title`, `subtitle`, `composer`, `lyricist`, `arranger` or `licenseText`, the metadatas will be instantly be updated, and a real-time action will be pushed to update the document lazily.
This pending document modification will be automatically be saved as a new version by either a connected client or our internal versioning service.
 """,
    tags=['score_tracking', 'collection_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def edit_score(score: str, body: ScoreModification = None):
    """
    Edit a score's metadata
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/collaborators',
    description=""" This API call will list the different collaborators of a score and their rights on the document. The returned list will at least contain the owner of the document.

Collaborators can be a single user (the object `user` will be populated) or a group (the object `group` will be populated).
 """,
    tags=['score_tracking', 'user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_collaborators(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'), score: str = ...
):
    """
    List the collaborators
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores/{score}/collaborators',
    description=""" Share a score with a single user or a group. This API call allows to add, invite and update the collaborators of a resource.
- To add an existing Flat user to the resource, specify its unique identifier in the `user` property.
- To invite an external user to the resource, specify its email in the `userEmail` property.
- To add a Flat group to the resource, specify its unique identifier in the `group` property.
- To update an existing collaborator, process the same request with different rights.
 """,
    tags=['user_account_management', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_score_collaborator(score: str, body: ResourceCollaboratorCreation = ...):
    """
    Add a new collaborator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/scores/{score}/collaborators/{collaborator}',
    description=""" Remove the specified collaborator from the score
 """,
    tags=['score_tracking', 'user_account_management', 'class_user_enrollment'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def remove_score_collaborator(score: str, collaborator: str = ...):
    """
    Delete a collaborator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/collaborators/{collaborator}',
    description=""" Get the information about a collaborator (User or Group).
 """,
    tags=['score_tracking', 'group_overview'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_collaborator(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    score: str = ...,
    collaborator: str = ...,
):
    """
    Get a collaborator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/comments',
    description=""" This method lists the different comments added on a music score (documents and inline) sorted by their post dates. """,
    tags=['comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_comments(
    type: Optional[Type7] = None,
    sort: Optional[Sort5] = None,
    direction: Optional[Direction] = None,
    score: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    List comments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores/{score}/comments',
    description=""" Post a document or a contextualized comment on a document.

Please note that this method includes an anti-spam system for public scores. We don't guarantee that your comments will be accepted and displayed to end-user. Comments are be blocked by returning a `403` HTTP error and hidden from other users when the `spam` property is `true`.
 """,
    tags=['comment_management', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_score_comment(
    score: str,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    body: ScoreCommentCreation = ...,
):
    """
    Post a new comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/scores/{score}/comments/{comment}',
    tags=['comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_score_comment(
    score: str,
    comment: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    Delete a comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/scores/{score}/comments/{comment}',
    tags=['comment_management', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_score_comment(
    score: str,
    comment: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    body: ScoreCommentUpdate = ...,
):
    """
    Update an existing comment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/scores/{score}/comments/{comment}/resolved',
    tags=['comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def mark_score_comment_unresolved(
    sharing_key: Union[
        Optional[str], Optional[str], Optional[str], Optional[str]
    ] = Query(None, alias='sharingKey'),
    score: str = ...,
    comment: str = ...,
):
    """
    Mark the comment as unresolved
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/scores/{score}/comments/{comment}/resolved',
    tags=['comment_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def mark_score_comment_resolved(
    score: str,
    comment: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    Mark the comment as resolved
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores/{score}/fork',
    description=""" This API call will make a copy of the last revision of the specified score and create a new score. The copy of the score will have a privacy set to `private`.

When using a [Flat for Education](https://flat.io/edu) account, the inline and contextualized comments will be accessible in the child document.
 """,
    tags=['score_forking', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def fork_score(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    score: str = ...,
    body: ScoreFork = ...,
):
    """
    Fork a score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/revisions',
    description=""" When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to list all of them, sorted by last modification.

Depending the plan of the account, this list can be trunked to the few last revisions.
 """,
    tags=['score_revision_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_revisions(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'), score: str = ...
):
    """
    List the revisions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores/{score}/revisions',
    description=""" Update a score by uploading a new revision for this one.
 """,
    tags=['score_revision_control', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_score_revision(score: str, body: ScoreRevisionCreation = ...):
    """
    Create a new revision
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/revisions/{revision}',
    description=""" When creating a score or saving a new version of a score, a revision is created in our storage. This method allows you to get a specific
revision metadata.
 """,
    tags=['score_revision_control', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_revision(
    score: str,
    revision: str = ...,
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
):
    """
    Get a score revision
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/revisions/{revision}/{format}',
    description=""" Retrieve the file corresponding to a score revision (the following formats are available): Flat JSON/Adagio JSON `json`, MusicXML
`mxl`/`xml`, MP3 `mp3`, WAV `wav`, MIDI `midi`, a tumbnail of the first page `thumbnail.png` or auto sync points `synchronizationPoints`.
 """,
    tags=['score_revision_control', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_revision_data(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    parts: Optional[str] = None,
    only_cached: Optional[bool] = Query(None, alias='onlyCached'),
    url: Optional[bool] = None,
    score: str = ...,
    revision: str = ...,
    format: Format = ...,
):
    """
    Get a score revision data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/submissions',
    description=""" This API call will list the different assignments submissions where the score is attached. This method can be used by anyone that are part of the organization and have at least read access to the document.
 """,
    tags=['submission_control', 'score_forking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_submissions(score: str):
    """
    List submissions related to the score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/tracks',
    tags=['track_management', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def list_score_tracks(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    assignment: Optional[str] = None,
    list_auto_track: Optional[bool] = Query(None, alias='listAutoTrack'),
    score: str = ...,
):
    """
    List the audio or video tracks linked to a score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores/{score}/tracks',
    description=""" Use this method to add new track to the score. This track can then be played on flat.io or in an embedded score.
This API method support medias hosted on SoundCloud, YouTube and Vimeo.
 """,
    tags=['track_management', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def add_score_track(score: str, body: ScoreTrackCreation = ...):
    """
    Add a new video or audio track to the score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/scores/{score}/tracks/{track}',
    tags=['track_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_score_track(score: str, track: str = ...):
    """
    Remove an audio or video track linked to the score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scores/{score}/tracks/{track}',
    tags=['track_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_score_track(
    sharing_key: Optional[str] = Query(None, alias='sharingKey'),
    score: str = ...,
    track: str = ...,
):
    """
    Retrieve the details of an audio or video track linked to a score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/scores/{score}/tracks/{track}',
    tags=['track_management', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_score_track(score: str, track: str = ..., body: ScoreTrackUpdate = ...):
    """
    Update an audio or video track linked to a score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scores/{score}/untrash',
    description=""" This method will remove the score from the `trash` collection and from the deletion queue, and add it back to the original collections.
 """,
    tags=['score_tracking', 'score_revision_control'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def untrash_score(score: str):
    """
    Untrash a score
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user}',
    description=""" Get a public profile of a Flat User.
 """,
    tags=['user_profile_access'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user(user: str):
    """
    Get a public user profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user}/likes',
    tags=['user_profile_access', 'score_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def ger_user_likes(ids: Optional[bool] = None, user: str = ...):
    """
    List liked scores
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{user}/scores',
    description=""" Get the list of public scores owned by a User.

**DEPRECATED**: Please note that the current behavior will be deprecrated on **2019-01-01**.
This method will no longer list private and shared scores, but only public scores of a Flat account.
If you want to access to private scores, please use the [Collections API](#tag/Collection) instead.
 """,
    tags=['score_tracking', 'user_profile_access'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user_scores(parent: Optional[str] = None, user: str = ...):
    """
    List user's scores
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
